{"path":"dspro2/6_deployment/Week 7_ Transformer/Transformer.pdf","text":"Information Technology Transformer NLP Andreas Marfurt 04.04.2024 Motivation BERT 2 https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html BERT image Motivation BERT 3 https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html BERT image PaLM 4https://ai.googleblog.com/2022/04/pathways-language-model-palm-scaling-to.html PaLM 5https://ai.googleblog.com/2022/04/pathways-language-model-palm-scaling-to.html ChatGPT 6https://openai.com/blog/chatgpt ChatGPT 7https://openai.com/blog/chatgpt GPT-4 8https://openai.com/research/gpt-4 GPT-4 9https://openai.com/research/gpt-4 DALLÂ·E 3 10https://openai.com/dall-e-3 A 3D render of a coffee mug placed on a window sill during a stormy day. The storm outside the window is reflected in the coffee, with miniature lightning bolts and turbulent waves seen inside the mug. The room is dimly lit, adding to the dramatic atmosphere. Tiny potato kings wearing majestic crowns, sitting on thrones, overseeing their vast potato kingdom filled with potato subjects and potato castles. DALLÂ·E 3 11https://openai.com/dall-e-3 A 3D render of a coffee mug placed on a window sill during a stormy day. The storm outside the window is reflected in the coffee, with miniature lightning bolts and turbulent waves seen inside the mug. The room is dimly lit, adding to the dramatic atmosphere. Tiny potato kings wearing majestic crowns, sitting on thrones, overseeing their vast potato kingdom filled with potato subjects and potato castles. Overview â€¢ Transformer idea â€¢ Architecture â€¢ Self-attention â€¢ Cross-attention â€¢ Feed-forward network â€¢ Query-key-value attention â€¢ Dot-product attention â€¢ Multi-head attention â€¢ Attention variants â€¢ Position encoding 12 Whatâ€™s wrong with RNNs? â€¢ Canâ€™t be parallelized b/c of recurrence â€¢ Hidden state â„ğ‘¡âˆ’1 must be computed before â„ğ‘¡ â€¢ Long-range dependencies hard to learn, even with LSTM/GRU architecture 13 Transformer â€¢ Vaswani et al., 2017 â€¢ What if we can parallelize computation on the entire sequence? â€¢ Idea 1: Use the attention mechanism instead of recurrence to relate words â€¢ Idea 2: Use attention from each word in a sequence to all other words â†’ self-attention 14 Computation in the Transformer â€¢ One output vector for every input vector 15 ğ‘¤1 ğ‘¤2 ğ‘¤3 ğ‘¤1 â€² ğ‘¤2 â€² ğ‘¤3 â€² Transformer Transformer Architecture 16Vaswani et al., 2017 Previously: Attention in RNNs â€¢ Attention from the decoder to encoder hidden states â€¢ Compute a context vector ğ‘ğ‘– for each decoder time step 17 â„1 â„2 â„3 ğ‘ğ‘– ğ›¼1 ğ›¼2 ğ›¼3 Self-attention in the Encoder â€¢ Attention from an input word to all other words in the input â€¢ â€œWhat is my meaning in the context of my surrounding words?â€ 18Vaswani et al., 2017 Self-attention in the Encoder â€¢ Each word ğ‘¤ğ‘– looks at all other words in the input 19 ğ‘¤1 ğ‘¤2 ğ‘¤3 ğ‘¤1 â€² ğ‘¤2 â€² ğ‘¤3 â€² ğ›¼1 ğ›¼2 ğ›¼3 Direction of arrows in diagram: Direction of attention: ğ‘¤1 â€² â€œlooksâ€ at ğ‘¤1, ğ‘¤2, ğ‘¤3 Data flow from ğ‘¤1, ğ‘¤2, ğ‘¤3 to ğ‘¤1 â€² ğ‘¤â€™1 = ğ›¼1ğ‘¤1 + ğ›¼2ğ‘¤2 + ğ›¼3ğ‘¤3 Self-attention in the Decoder â€¢ During decoding: Words are not allowed to look into the future â€¢ Since our task is to generate the next word from the prefix â€¢ If your model gets 0 training loss very quickly, check if information from future words leaks to the current word â€¢ Still want to train the entire sequence in parallel â€¢ Idea: Causal mask â€¢ Word ğ‘¤1 â€² can only see words ğ‘¤â‰¤1 â€¢ Vectorize computation: Write everything as matrix operations to run efficiently on GPUs/TPUs 20Vaswani et al., 2017 Self-attention in the Decoder â€¢ Words canâ€™t see the future 21 ğ‘¤1 ğ‘¤2 ğ‘¤3 ğ‘¤1 â€² ğ‘¤2 â€² ğ‘¤3 â€² ğ›¼1 ğ›¼2 ğ›¼3 ğ‘¤1 ğ‘¤2 ğ‘¤3 ğ‘¤1 â€² ğ‘¤2 â€² ğ‘¤3 â€² ğ›¼1 ğ›¼2 ğ›¼3 ğ‘¤1 â€²ğ‘¤1 ğ‘¤1 â€²ğ‘¤2 ğ‘¤1 â€²ğ‘¤3 ğ‘¤2 â€² ğ‘¤1 ğ‘¤2 â€² ğ‘¤2 ğ‘¤2 â€² ğ‘¤3 ğ‘¤3 â€² ğ‘¤1 ğ‘¤3 â€² ğ‘¤2 ğ‘¤3 â€² ğ‘¤3 Self-attention in the Decoder â€¢ Causal mask in matrix notation 22 Interaction matrix Causal mask * = 1 0 0 1 1 0 1 1 1 ğ‘¤1 â€²ğ‘¤1 0 0 ğ‘¤2 â€² ğ‘¤1 ğ‘¤2 â€² ğ‘¤2 0 ğ‘¤3 â€² ğ‘¤1 ğ‘¤3 â€² ğ‘¤2 ğ‘¤3 â€² ğ‘¤3 ğ‘¤1 â€²ğ‘¤1 ğ‘¤1 â€²ğ‘¤2 ğ‘¤1 â€²ğ‘¤3 ğ‘¤2 â€² ğ‘¤1 ğ‘¤2 â€² ğ‘¤2 ğ‘¤2 â€² ğ‘¤3 ğ‘¤3 â€² ğ‘¤1 ğ‘¤3 â€² ğ‘¤2 ğ‘¤3 â€² ğ‘¤3 Self-attention in the Decoder â€¢ Causal mask in matrix notation 23 Interaction matrix Causal mask * = 1 0 0 1 1 0 1 1 1 ğ‘¤1 â€²ğ‘¤1 0 0 ğ‘¤2 â€² ğ‘¤1 ğ‘¤2 â€² ğ‘¤2 0 ğ‘¤3 â€² ğ‘¤1 ğ‘¤3 â€² ğ‘¤2 ğ‘¤3 â€² ğ‘¤3 element-wise multiplication Cross-attention â€¢ Attention from the decoder to the encoder â€¢ This is what we saw in RNNs as well â€¢ We will see later what the two arrows mean that come from the encoder (these are the keys and values in QKV attention) 24Vaswani et al., 2017 Feed-forward Network (FFN) â€¢ Applies the following operations: â€¢ Linear layer â€¢ ReLU (GELU/SwiGLU in modern LLMs) â€¢ Linear layer â€¢ First linear layer is an up-projection: Projects into higher dimension (512 â†’ 2048 in the paper) â€¢ This is called the â€œinnerâ€ dimension of the FFN â€¢ Second layer projects down to 512- dimensional vector again 25Vaswani et al., 2017 Role of FFN â€¢ Still a topic of research what exactly they add â€¢ In general: adding a non-linearity (such as a ReLU) to a network increases the complexity of functions it can implement â€¢ Up-projection for the inner dimension: Potentially disentangles some factors of variation such that they can be treated separately by the non-linearity 26 A Note on Layers â€¢ What is a layer in this architecture? â€¢ Sometimes a Transformer block (attentions + FFN) is called a Transformer layer â€¢ And self-attention, cross-attention and FFN are called sublayers â€¢ But with the original definition of a layer, just the FFN consists of at least 2 layersâ€¦ â€¢ Make sure people know what you are talking about by giving context â€¢ â€¦ and ask if youâ€™re unsure! 27Vaswani et al., 2017 Intuition: Skip/Residual Connections â€¢ Direct connections around a (sub)layer â€¢ Shorter path length â†’ better gradient flow 28Vaswani et al., 2017 Advanced Intuition: (Topological) Spaces â€¢ ML researchers/practitioners are often talking about spaces â€¢ Embedding space â€¢ Latent space â€¢ Query/key/value space â€¢ Feature space (e.g. vision vs. text in multimodal models) â€¢ We can map from one space to the other with the help of a projection â€¢ If we map from higher dimensional (e.g. one-hot vector) to lower dimensional (300-dimensional word vectors), we also call the mapping an embedding, i.e. we embed an object (=word) into the 300-dimensional latent/embedding space 29 Advanced Intuition: (Topological) Spaces â€¢ Imperfect analogy: RGB vs. hexadecimal â€œcolor spacesâ€ â€¢ Different coordinate systems for describing colors â€¢ Can map from one system to the other â€¢ Can perform operations (e.g. addition, increasing hue) on the elements of the same system, but not on elements from two different systems â€¢ Same with NN spaces: adding vectors in different spaces is not meaningful â€¢ Project to same space, then perform the operation â€¢ Lucky for us: we let the model learn this projection 30 Query-Key-Value Attention 31 QKV Attention â€¢ New way to look at attention â€¢ Attention consists of 3 parts â€¢ Queries: formulate questions on new information that we need â€¢ Keys: match the queries if they have that type of information â€¢ Values: contain the information â€¢ Attention function tries to find matching keys for queries â†’ computes attention weights (= how well they match) â€¢ Attention weights are multiplied with the values to give us the new information 32 QKV Attention â€¢ How does original attention match this view? â€¢ Queries: Previous decoder hidden state â€¢ Keys: Encoder hidden states â€¢ Values: Encoder hidden states 33 Attention Definition â€¢ Context vector ğ‘ğ‘– â€¢ a weighted sum of encoder hidden states â€¢ computed for each decoding time step ğ‘ğ‘– = à· ğ‘—=1 ğ‘› ğ›¼ğ‘–ğ‘—â„ğ‘— (enc) â€¢ Attention weights ğ›¼ğ‘–ğ‘— ğ›¼ğ‘–ğ‘— = softmax ğ‘’ğ‘–ğ‘— = exp ğ‘’ğ‘–ğ‘— Ïƒğ‘˜=1 ğ‘› exp ğ‘’ğ‘–ğ‘˜ â€¢ Attention function ğ‘“att ğ‘’ğ‘–ğ‘— = ğ‘“att â„ğ‘–âˆ’1 (dec), â„ğ‘— (enc) 34 i: time step in decoder j: time step in encoder previous decoder hidden state current encoder hidden state Attention Definition â€¢ Context vector ğ‘ğ‘– â€¢ a weighted sum of encoder hidden states â€¢ computed for each decoding time step ğ‘ğ‘– = à· ğ‘—=1 ğ‘› ğ›¼ğ‘–ğ‘—â„ğ‘— (enc) â€¢ Attention weights ğ›¼ğ‘–ğ‘— ğ›¼ğ‘–ğ‘— = softmax ğ‘’ğ‘–ğ‘— = exp ğ‘’ğ‘–ğ‘— Ïƒğ‘˜=1 ğ‘› exp ğ‘’ğ‘–ğ‘˜ â€¢ Attention function ğ‘“att ğ‘’ğ‘–ğ‘— = ğ‘“att â„ğ‘–âˆ’1 (dec), â„ğ‘— (enc) 35 i: time step in decoder j: time step in encoder previous decoder hidden state current encoder hidden state Values Queries Keys QKV Attention â€¢ How does original attention match this view? â€¢ Queries: Previous decoder hidden state â€¢ Keys: Encoder hidden states â€¢ Values: Encoder hidden states â€¢ New: separate keys and values (through projections) 36 What are the queries, keys and values in Transformer? â€¢ Linear projections (ğ‘Šğ‘¥ + ğ‘) of the input â€¢ Different weights & biases for Q, K, V â€¢ Self-attention â€¢ Inputs to the Transformer block â€¢ Cross-attention â€¢ Queries: Output of decoder self-attention â€¢ Keys & values: Final layer encoder hidden states 37Vaswani et al., 2017 Dot-product Attention â€¢ We saw multiplicative attention for RNNs: ğ‘“att â„ğ‘–âˆ’1 (dec), â„ğ‘— (enc) = â„ğ‘–âˆ’1 (dec)ğ‘Šâ„ğ‘— (enc) â€¢ Transformer uses scaled dot-product attention: ğ‘“att ğ‘ğ‘–, ğ‘˜ğ‘— = ğ‘ğ‘–ğ‘˜ğ‘— âŠ¤ ğ‘‘ ğ‘‘ is the dimension of ğ‘ğ‘–, ğ‘˜ğ‘— 38 ğ‘ğ‘–, ğ‘˜ğ‘— are the output of projections themselves Dot-product Attention â€¢ We saw multiplicative attention for RNNs: ğ‘“att â„ğ‘–âˆ’1 (dec), â„ğ‘— (enc) = â„ğ‘–âˆ’1 (dec)ğ‘Šâ„ğ‘— (enc) â€¢ If we write out Transformer scaled dot-product attention and use â„ğ‘–âˆ’1 (dec), â„ğ‘— (enc) as inputs: ğ‘“att ğ‘ğ‘–, ğ‘˜ğ‘— = ğ‘ğ‘–ğ‘˜ğ‘— âŠ¤ ğ‘‘ = ğ‘Šğ‘â„ğ‘–âˆ’1 (dec) + ğ‘ğ‘ ğ‘Šğ‘˜â„ğ‘— (enc) + ğ‘ğ‘˜ âŠ¤ ğ‘‘âˆ’1 2 39 Dot-product Attention â€¢ We saw multiplicative attention for RNNs: ğ‘“att â„ğ‘–âˆ’1 (dec), â„ğ‘— (enc) = â„ğ‘–âˆ’1 (dec)ğ‘Šâ„ğ‘— (enc) â€¢ If we write out Transformer scaled dot-product attention and use â„ğ‘–âˆ’1 (dec), â„ğ‘— (enc) as inputs: ğ‘“att ğ‘ğ‘–, ğ‘˜ğ‘— = ğ‘ğ‘–ğ‘˜ğ‘— âŠ¤ ğ‘‘ = ğ‘Šğ‘â„ğ‘–âˆ’1 (dec) + ğ‘ğ‘ ğ‘Šğ‘˜â„ğ‘— (enc) + ğ‘ğ‘˜ âŠ¤ ğ‘‘âˆ’1 2 40 Added 1 projection matrix, 2 biases, 1 scalar Dot-product Attention â€¢ Transformer attention function: ğ‘“att ğ‘ğ‘–, ğ‘˜ğ‘— = ğ‘ğ‘–ğ‘˜ğ‘— âŠ¤ ğ‘‘ â€¢ Attention weights (as before): ğ›¼ğ‘–ğ‘— = softmax ğ‘“att ğ‘ğ‘–, ğ‘˜ğ‘— â€¢ Attention output (previously our context vector): output = à· ğ‘—=1 ğ‘› ğ›¼ğ‘–ğ‘—ğ‘£ğ‘— 41 Dot-product Attention We can write all of this in matrix notation: Attention ğ‘„, ğ¾, ğ‘‰ = softmax ğ‘„ğ¾âŠ¤ ğ‘‘ ğ‘‰ 42Vaswani et al., 2017 Multi-head Attention â€¢ Transformer adds 1 more trick: multi-head attention 1. Split the input to the attention function into â„ chunks of dimension ğ‘‘/â„ (â„ is the number of heads, donâ€™t confuse with RNN hidden states) 2. Compute attention on each chunk separately 3. Concatenate the result 43Vaswani et al., 2017 1 2 3 4 5 6 1 2 3 4 5 6 a b c d e f Attention( ) Attention( ) Attention( ) Multi-head Attention â€¢ Transformer adds 1 more trick: multi-head attention 1. Split the input to the attention function into â„ chunks of dimension ğ‘‘/â„ (â„ is the number of heads, donâ€™t confuse with RNN hidden states) 2. Compute attention on each chunk separately 3. Concatenate the result 44Vaswani et al., 2017 1 2 3 4 5 6 1 2 3 4 5 6 a b c d e f Attention( ) Attention( ) Attention( ) These are called attention heads Attention Variants â€¢ Multi-query attention â€¢ Shazeer, 2019 â€¢ Instead of h heads for keys/values, use only 1 head â€¢ Keep h heads for queries â€¢ Grouped query attention â€¢ Ainslie et al., 2023 â€¢ Groups of keys/values (can be chosen to equal the number of GPUs) â€¢ Used in modern LLMs for efficiency 45Ainslie et al., 2023 Transformer Attention Output â€¢ We no longer use the context vector to predict the next hidden state â€¢ Instead, the attention output is our next hidden state â€¢ We refine this representation over multiple iterations of self-attention â†’ (cross- attention in the decoder â†’) FFN â€¢ Around each attention and FFN block, there is a residual connection â€¢ The input to the block gets added to the output, and layer normalization is applied 46Vaswani et al., 2017 Layer Normalization â€¢ Purpose: Keep activations (= hidden states) in a similar range across layers â†’ No explosion/vanishing of activations â†’ No explosion/vanishing of gradients â€¢ Goal: Get outputs with 0 mean and unit variance ğ‘¦ = ğ‘¥ âˆ’ E ğ‘¥ Var ğ‘¥ + ğœ– âˆ— ğ›¾ + ğ›½ ğ›¾, ğ›½ are learnable parameters 47https://pytorch.org/docs/stable/generated/torch.nn.LayerNorm.html Layer Normalization â€¢ Purpose: Keep activations (= hidden states) in a similar range across layers â†’ No explosion/vanishing of activations â†’ No explosion/vanishing of gradients â€¢ Goal: Get outputs with 0 mean and unit variance ğ‘¦ = ğ‘¥ âˆ’ E ğ‘¥ Var ğ‘¥ + ğœ– âˆ— ğ›¾ + ğ›½ ğ›¾, ğ›½ are learnable parameters 48https://pytorch.org/docs/stable/generated/torch.nn.LayerNorm.html Iâ€™m not sure these are necessaryâ€¦ query length key length vector dim Complexity of Attention â€¢ Every query ğ‘ğ‘– looks at every key ğ‘˜ğ‘— â€¢ This mean m x n x d multiplications in the dot-product â€¢ m = n for self-attention â€¢ For long inputs, this can be quite costlyâ€¦ â€¢ There are multiple approaches that try to make attention more efficient, e.g. Transformer-XL, Longformer, Performer, â€¦ â€¢ We wonâ€™t talk about them in this class 49 Position Encoding 50 Why do we need position encoding? â€¢ RNNs â€¢ Process input sequentially â€¢ It is clear which word came before and after â€¢ Transformers â€¢ Process the entire sequence in parallel â€¢ When we compare the word at position ğ‘– to that at position ğ‘—, how do we know their order and how far apart they are? â†’ Position encoding 51 Types of Position Encoding â€¢ Absolute position encoding â€¢ As a function of the position â€¢ As a learned embedding â€¢ Relative position embeddings 52 Absolute Position Encoding â€¢ For an input word at position ğ‘–, create a ğ‘‘-dimensional vector â€¢ The entries at dimension ğ‘— of this position vector are: pos ğ‘–, 2ğ‘— = sin ğ‘–/10000 2ğ‘—/ğ‘‘ pos ğ‘–, 2ğ‘— + 1 = cos ğ‘–/100002ğ‘—/ğ‘‘ 53Vaswani et al., 2017 Absolute Position Encoding â€¢ For an input word at position ğ‘–, create a ğ‘‘-dimensional vector â€¢ The entries at dimension ğ‘— of this position vector are: pos ğ‘–, 2ğ‘— = sin ğ‘–/10000 2ğ‘—/ğ‘‘ pos ğ‘–, 2ğ‘— + 1 = cos ğ‘–/100002ğ‘—/ğ‘‘ 54Vaswani et al., 2017 0 1 2 3 4 â€¦ even odd Absolute Position Embedding â€¢ Learn a separate embedding for each position ğ‘– = 1, â€¦, max_pos â€¢ max_pos: Maximum input length that was used during training, typically 512 (BERT) or 1024 (BART) â€¢ How do we deal with longer inputs? â€¢ Truncate input â€¢ Copy the position embedding at the last position for each following position â€¢ Absolute position embeddings are added to the word embeddings at the input 55Vaswani et al., 2017 Absolute Position Encoding vs. Embedding â€¢ Performance the same â€¢ Advantage for absolute position encoding: Works for any input lengthâ€¦ â€¢ â€¦ but absolute position embeddings are always used in practice â€¢ For standard Transformers, very long inputs are not the typical input â€¢ Transformers that are designed to deal with long inputs either train larger position embeddings, or have a different strategy to deal with position 56 Relative Position Embedding (only for self-attention) â€¢ Shaw et al., 2018 â€¢ Learn embeddings for relative positions: ğ‘– âˆ’ ğ‘— = -max_dist, â€¦, -1, 0, 1, â€¦, max_dist â€¢ They use max_dist = 16 in the paper â€¢ Distance to between words at positions ğ‘– and ğ‘—: ğ‘– âˆ’ ğ‘— = âˆ’3 â€¢ Canâ€™t add them to input word embeddings: A different embedding has to be used for each output position â†’ Embeddings are added during attention computation instead 57 ğ‘¤ğ‘– ğ‘¤ğ‘–âˆ’1 ğ‘¤ğ‘–âˆ’2 ğ‘¤ğ‘— ğ‘¤ğ‘–+1 Relative Position Embedding â€¢ Standard attention function: ğ‘“att ğ‘ğ‘–, ğ‘˜ğ‘— = ğ‘ğ‘–ğ‘˜ğ‘— âŠ¤ ğ‘‘ â€¢ Attention function with relative position embeddings posğ‘–âˆ’ğ‘—: ğ‘“att ğ‘ğ‘–, ğ‘˜ğ‘— = ğ‘ğ‘– ğ‘˜ğ‘— + posğ‘–âˆ’ğ‘— âŠ¤ ğ‘‘ â€¢ Shaw et al., 2018 has another relative position term for distance of queries to values, but that one doesnâ€™t help 58 Rotary Position Embedding (RoPE) â€¢ Su et al., 2024 (initial version from 2021) â€¢ Relative position embedding used in modern LLMs â€¢ Multiplies queries and keys with rotation matrix â€¢ Different rotation matrix for every position â€¢ Multiplying two rotation matrices will give the rotation matrix of the relative position difference â€¢ Works with linear attention variants â€¢ Inner product decreases with larger distances 59Su et al., 2024","libVersion":"0.3.2","langs":""}